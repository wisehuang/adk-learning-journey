# Google Agent SDK 入門 (5): 開發者思維

## 概念層面比較：開發者思維、責任分工與任務拆解

**開發者心智模型的轉變：函式導向 vs. 代理導向。** 傳統開發中，工程師習慣於以**函式或API調用序列**來思考問題解決步驟：從輸入開始，按既定順序調用一系列函式庫或服務，最後彙總輸出結果。在這種函式導向的習慣下，每個子任務的執行都是由程式明確調用，工程師充當了「指揮者」的角色，安排好所有步驟。然而，在 Agent 導向的架構下，思維方式需要相應改變。開發者更像是在**設計一個社群**：定義多個能自主執行子任務的 Agent，並考慮它們如何透過訊息與協定互動，而非親自指揮每一步。也就是說，從「寫流程」轉變為「**配置社群**」——規劃好有哪些智能體，各自目標是什麼，遇到狀況時該如何通信協調。由於 Agent 具備一定自主性（透過內建的 LLM 模型決策），開發者需要習慣讓渡部分細節控制，改為在更高層次制定規則和監督流程。

**系統職責分工與任務拆解。** 在單體模式下，任務拆解往往只是代碼層面的，例如將大函式拆成幾個子函式，或在一個流程中插入多次 API 調用。但本質上整個任務仍由**同一邏輯主體**負責，沒有真正意義上的角色分離。相較之下，多代理架構 (multi-agent framework) 鼓勵在**架構層面**進行責任分工：按照任務的不同方面創建專門的 Agent，各司其職。例如，在 *meeting\_workflow* 專案中，就將會議預訂流程拆解為三個 Agents：一個負責驗證會議參與者輸入（一律檢查 email 格式）、一個負責與 Google 日曆整合進行排程衝突檢測、以及一個負責通知生成與發送。這三個 Agents 透過順序代理串聯成完整工作流，各自處理自己擅長的部分，**清晰的職責邊界**使系統更易於維護和調試。如果採傳統方式實作，同樣功能可能由一個模組或腳本連貫完成，開發者需要在代碼中手動依序調用「驗證 -> 排程 -> 通知」，所有邏輯混在一起，不利於復用和獨立演進。

多代理架構下的任務拆解，有點類似現實中的團隊合作：將大目標拆成多個專業子任務，由不同角色同步完成，最後彙總成果。*multi\_agent\_pm* 專案便是一個很好例子：它模擬了一個軟體開發專案管理場景，系統內部設計了\*\*經理 (Manager)、工程 (Engineering) 和測試 (QA/Test)\*\*三種智能 Agent 來互動合作。經理 Agent 負責統籌規劃、分配任務，工程 Agent 執行開發工作，測試 Agent 進行品質檢查。透過 A2A 通訊，這些 Agents 可以相互發出請求和彙報進度，彷彿真有人在協作一般。這種架構使得每個 Agent 的對話上下文都聚焦在自身職責領域（例如工程Agent主要討論技術任務細節），避免了一個單體模型試圖記憶和處理所有資訊的混亂。同時，如果日後需要擴充更多角色（例如加入產品設計代理），只需增加新的 Agent 並定義其與現有 Agent 的互動即可，對整體影響不大。

總而言之，概念層面的最大差異在於：**從命令電腦執行步驟，轉變為設定智能體間的對話與合作。**開發者必須學會站在更高的層次去思考問題抽象，把原先寫死在程式碼裡的流程轉化為 Agent 之間的協議與互動。同時也要調整心態，接受 AI Agent 具有一定自治性這一事實，允許它們各自完成任務後再組裝結果。這種思維轉變需要時間適應，但有助於打造更**彈性**且**智能**的軟體系統。

## 工程師開發心智模型的轉變建議（從函式導向到代理導向）

面對上述的新架構與協定，傳統工程師勢必要進行一些心態與技能上的調整。正如業界觀察人士所指出的：「當下爆火的 MCP 不過是 Agent 時代的前夜，而 Google 發布的 ADK、A2A 則才剛剛拉開 Agent 時代的序幕」。這意味著軟體開發正迎來一個從函式調用轉向 AI Agent 協作的新紀元。以下是幾點給工程師的建議，希望可以平順完成從函式導向到代理導向的心智轉變：

* **培養「架構師」視角**：習慣從全局出發思考問題，將應用劃分為不同的智能體角色，而非把所有步驟寫在一個流程裡。問自己：這個需求可以拆分成哪些獨立的子任務？是否可以對應到不同類型的 Agent 去處理？例如，處理客服請求的系統也許可以有「詢問分析Agent」、「資料檢索Agent」和「回答生成Agent」各司其職，而非讓單一模型串聯完成。這需要跳脫細節，先制定宏觀方案再落實微觀實現。

* **熟悉新工具與協定**：投入時間學習 ADK 框架的使用以及 A2A、MCP 等協定的規範。這些工具降低了實作代理模式的門檻，但前提是瞭解其設計理念和最佳實踐。例如，了解如何編寫 ADK 的 Tool、如何定義 Agent 的 `.well-known/agent.json` 檔案讓其介接 A2A，以及MCP伺服器的基本構造。掌握這些知識後，再實際將其運用到小型專案中，以**由淺入深**的方式逐步建立信心。

* **轉換設計方法論**：在傳統開發中，我們常用**物件導向**或**函式式**的方法進行設計；而在代理導向開發中，可以借鑑的是**Actor模型**或**微服務架構**的設計理念。每個 Agent 可被視為一個獨立的Actor/微服務，擁有自己的狀態和行為，透過訊息（協定）與他人互動。因此，在設計階段，多考慮代理間的**介面定義**和**溝通流程**（例如定義 Agent 能接受哪些指令/訊息，輸出何種結果），而不是只關注函式的參數和返回值。這類似於定義服務介面契約，只不過對象變成了 AI Agent。

* **強調異步與容錯思維**：Agent 協作往往涉及**異步**交互和**不確定性**。要做好心理準備：不像傳統函式呼叫那樣「呼叫就立即返回結果」，Agent 之間的對話可能有延遲，甚至可能需要多輪來回才能完成。此外，Agent 作為基於ML模型的系統，其行為具有隨機性和不確定性，可能出現理解錯誤或意外輸出。因此，開發者在設計流程時要考慮容錯機制，例如設定超時重試策略、增加結果驗證步驟，或在關鍵環節引入人工確認（Human in the loop）。這種對非確定性結果進行控制的意識，是 Agent 導向開發的重要組成部分。

* **逐步遷移，積累經驗**：心智模式的改變非一蹴可幾。建議從小處著手，例如在現有傳統應用中**選擇一個子功能**嘗試以 Agent 方式重構，或者利用 ADK 開發一個簡單的多代理demo專案。透過實踐來體會 Agent 協作的優劣，逐步建立對新 design pattern 的直覺。一開始不妨將 Agent 數量控制在少數，流程相對簡單，待熟悉後再擴大規模。每次迭代都反思：哪些地方 Agent 的引入帶來了好處？哪些地方反而增加了複雜度？藉此調整未來架構設計的策略。

總之，從函式導向轉向 Agent 導向，代表著從**執行指令**的細節管理者轉變為**協調智能體**的設計者。工程師需要擴展技能組合，既要懂AI模型與自然語言交互，也要有分散式系統的設計思維。隨著產業快速朝這方向發展，提早擁抱並掌握這種心智模型轉變，將使你在未來的軟體開發浪潮中處於領先位置。

## 小結與實際應用情境建議

\*\*總結差異：\*\*Google ADK + A2A 引領的多 Agent 協作開發模式，與 MCP/傳統 API 單體模式相比，在技術實作上提供了更高的模組化和可擴展性，在概念思維上要求開發者從指令式編排轉向 Agent 間互動。ADK/A2A 架構透過將任務分解到多個自治組件，降低了單點複雜度，並利用標準協定實現了 Agent to Agent 、Agent 與工具(Tool)之間的無縫溝通。相對地，傳統單體模式強調由單一流程掌控全局，適合結構清晰且步驟固定的任務，但在面對高度複雜或易變的需求時往往力不從心。

**適用場景建議：**如果你的應用涉及**多步驟的複雜流程**、**跨領域的任務協同**或**需要高度靈活的決策流程**，那麼採用多代理架構會比較有利。例如，企業內部的自動化助手需要同時和多個部門系統互動（行銷、客服、資料分析等），就非常適合將不同職能拆分給不同Agent處理，再由一個統籌 Agent 彙總。ADK 提供的工具讓你能較快速地搭建這類系統，同時A2A協定確保了未來擴充新 Agent 的兼容性。如果是**單一步驟、目標明確**的任務（例如查詢天氣、計算匯率），傳統API調用或 OpenAI 函式調用 (Function calling) 可能就已足夠。畢竟，對於過於簡單的需求，引入 multi-agent 反而可能增加不必要的開銷。所以在架構選型時，應權衡任務的**複雜度**與**規模**：小型且固定流程→傳統方式較簡潔；大型且需要動態協作→ Agent 架構更適合。

值得一提的是，ADK 與 MCP 並非對立關係——實際上它們可以互補使用。開發者完全可以在 ADK 的 Agent 內部透過 MCP 協定來調用外部工具服務。未來的 AI 系統或許同時包含「能與他人對話合作的 Agent」（用A2A）以及「能透過標準接口調用工具的 Agent」（用MCP）。因此，熟悉兩種協定並瞭解其最佳組合將是未來趨勢的一部分。總結來說，Google ADK 和 A2A 開啟了新的開發 design pattern，帶來了對**開發者心智模型**的挑戰與革新。透過上文比較，我們看到這種轉變不僅是工具和架構的更新，更是開發理念的升級。建議工程團隊在合適的應用場景下勇於嘗試 Agent 導向的開發方式，在小範圍內驗證其價值。一旦掌握了相關技能與心法，你將能打造出更智能、自主且易於擴充的AI應用系統，在瞬息萬變的技術浪潮中保持競爭力。

\*\*參考來源：\*\*本文說明內容參考了部落客與文獻資料，如: Simon Liu 對 ADK/MCP/A2A 的介紹、Koyeb 技術博客對 A2A 與 MCP 協定的分析等，希望這篇比較分析能幫助一般工程師理解 **Google ADK 與 A2A** 相較 **傳統單體架構與 API 調用**的核心差異，並在日常開發中靈活運用，順利踏入多智能體協作的未來。

在接下來的章節中，我想學習將代理部署到 Vertex AI 的過程、將其容器化以及設置監控。