# Google Agent SDK 入門(4): Google ADK 和 A2A vs MCP 和傳統 API

## Google ADK 與 Agent-to-Agent (A2A) 的核心架構與開發方式

自我學習到這邊，我決定停下腳步，根據上面幾個專案給我的經驗，重新思考 A2A 的開發模式與MCP/傳統 API 的開發模式有合不同。

Google 在 2025 年推出的 Agent Development Kit（ADK）是一套開源的 Python 工具包，旨在簡化並加速 AI **代理（Agent）**的開發、測試與部署。ADK 強調**模組化**與**彈性**，允許開發者定義不同類型的智能代理，並提供記憶體、工具調用、任務協調等功能，用以構建現代 AI Agent 系統。ADK 本身與 Google 生態（如 Vertex AI、Gemini 模型）高度整合，但也支援其他模型與工具，使開發者能專注於代理邏輯而非底層雜務。

**Agent2Agent（A2A）協定**是 Google 提出的開放標準，專注於**代理與代理之間的通信**。簡單來說，A2A 定義了一套通用語言和介面，讓不同平台或架構下的 AI Agent 彼此「對話」協作。例如，在 A2A 下，每個 Agent 將對外暴露標準的 /run API 端點與對應的描述檔，其他 Agent 或 App 即可透過這個介面發送請求並獲取回應。A2A 解決了過去無法互通的痛點，被視為讓 AI 代理**跨框架協同**的關鍵。換言之，如果把不同 AI Agent 比喻為在同一系統中的不同角色，A2A 就像提供了一條**外交專線**讓它們能直接溝通協調，共同完成任務。

在 ADK 的架構中，A2A 扮演重要角色：ADK 建立的每個 Agent 具備的 A2A 通訊介面，可以方便地與其他 Agents 或系統整合。開發者可以使用 ADK 定義好 Agent 的行為，再透過 A2A 協定讓這些 Agent 相互調用彼此的能力，形成**多代理協作**的應用。ADK 支援將多個 Agent 以**串行、並行或階層式**等方式組合起來。例如，ADK 提供了 SequentialAgent 這類**工作流代理**（Workflow Agent）來負責組織"子Agent"的執行順序；也可以建立階層結構的代理，一個主要 Agent 根據需要調度下層的專職 Agent。這種「** Agent orchestrator**」的開發方式讓複雜任務的拆解與協調變得更為簡單。實際上，ADK 可以同時滿足**單一Agent**和**多Agent**兩種開發需求：對於簡單任務，可以只建立單個 Agent 並為其配置所需工具（如範例專案 *multi\_tool\_agent* 展示了如何迅速打造一個具備多種工具的 AI Agent）；而面對較複雜的流程，則可以建立多個專責代理共同合作（如 *meeting\_workflow* 專案透過三個子代理協作完成會議安排流程，*multi\_agent\_pm* 專案則模擬了多代理協同進行專案管理）。

## MCP 架構與傳統 API 呼叫方式的典型流程

**模型上下文協定（MCP, Model Context Protocol）**是 Anthropic 公司在 2024 年提出的一種開放標準，它被譽為 AI 行業的「USB-C 介面」，旨在統一大型語言模型（LLM）與**外部工具/資料來源**連接的方式。MCP 規定了Agent（或模型）如何透過標準化介面來調用外部資源，例如資料庫查詢、網路服務或其他軟體 API。換句話說，MCP 將過去每個應用各自為政的 API 接入方式加以標準化，使**AI Agent 與軟體服務之間的互動**更加一致。透過 MCP，一個 AI 助手類的 Agent 可以方便地呼叫各種已實現 MCP 介面的工具伺服器，如查詢資料庫、讀取檔案、執行網路搜尋等，無需為每種新工具重新設計溝通方法。

典型的 MCP 架構下，人們常採用\*\*「單主體指令模式」**來組織應用邏輯。所謂單主體（Monolithic）是指主要邏輯由**一個中央 Agent（或應用）**掌控，而指令模式則意指這個 Agent 會根據需要**逐步發出工具調用指令\*\*，完成各項子任務。例如，在沒有多 Agent 協作時，一個聊天機器人要完成行程安排，可能在內部按順序執行：「檢查輸入 → 調用航班API查詢 → 調用飯店API查詢 → 整合結果 → 回答用戶」。這整個流程由**單一Agent或程式**串連各步驟，透過傳統方式直接呼叫外部API 並處理回應。開發者需要自行撰寫每個API呼叫的邏輯，包括請求參數準備、錯誤處理和結果解析等。**傳統 API 呼叫模式**的特點是開發人員完全掌控流程細節，一步步明確調用函式或發HTTP請求去完成任務。

採用傳統方式時，如果要讓 AI 模型使用工具，通常有兩種路徑：其一是像 OpenAI Function Calling 那樣，讓模型在對話中**引用預先定義的函式**，再由外部程式碼攔截函式調用並執行對應API；其二是開發者在應用程式中寫好整個**順序邏輯**，在適當時機將查詢結果餵給模型。無論哪種方式，本質上都是**透過程式碼直接串接**模型與功能模組。由於缺乏統一標準，不同工具之間的整合方式各異，開發者的心智模型往往停留在**函式導向**：即把 AI 視為調用各種函式庫或API的發起者，自己則充當編排者，線性地安排執行順序。這種架構的優點是對於簡單任務直觀明瞭，但當流程變得複雜時，所有邏輯都耦合在單一系統內，可能導致代碼難以維護和擴展。

值得注意的是，MCP 協議的出現使上述傳統模式得到了一定升級——開發者可選擇將部分工具整合改由標準化的 MCP **工具伺服器**來承載。例如，Claude 等先進 AI 模型現在能透過 MCP 介面來調用外部知識庫或執行程式。不過即使使用 MCP，若整個應用僅有一個主要 Agent，那在架構上仍屬於**單體代理**：由單個智慧體串行地對接眾多工具。在這種情況下，Agent 與工具之間雖然透過MCP實現了更一致的接口，但**開發流程**上依舊是傳統的「計劃->調用->控制結果」式樣，開發者需要針對複雜任務自行拆解步驟並編寫控制邏輯。總而言之，MCP 提供了**工具整合的標準**，使 Agent 善用外部能力更方便；而 A2A/ADK 引入了**代理協作的架構**，改變了我們組織程式邏輯的思維方式。以下將從技術與概念兩個層面詳細比較這些新舊模式的差異。

## 技術層面比較：模組化、狀態管理、流程控制等差異

下面從技術實作角度，以表格比較 **ADK/A2A 多代理模式** 與 **MCP/傳統API單體模式** 在關鍵維度上的差異：

| 比較面向      | ADK/A2A 開發模式                                                                      | MCP/傳統 API 模式                                                            |
| --------- | --------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| **模組化程度** | **高模組化**：以多個專職 Agent 組成系統，各Agent通過標準介面協作，職責單一明確。                                  | **低模組化**：大多為單一應用或單一 Agent 涵蓋所有功能，透過函式調用串聯，職責界線模糊、耦合度高。                         |
| **狀態管理**  | **內建狀態管理**：框架提供會話記憶與上下文管理機制（如 ADK 的 Session Service），Agent 可方便存取共享資訊。             | **自行維護狀態**：需由開發者在程式中手動維護上下文，或依賴模型自身的提示記憶，缺乏統一策略，易出現狀態同步問題。               |
| **流程控制**  | **靈活工作流控制**：支援順序、平行、分層等執行流程控制，例如使用 SequentialAgent 編排多步驟任務。框架自帶調度機制，協調代理執行順序。     | **線性程式流程**：執行流程須由開發者以程式碼硬編碼串接，每步邏輯和調用順序手工實現。缺乏高層次抽象，難以避免流程錯綜複雜。          |
| **錯誤處理**  | **細粒度錯誤處理**：ADK 等框架提供中介層，可對工具錯誤進行攔截、重試策略、回退方案等統一管理，提升可靠性。                         | **手動錯誤處理**：每個 API 呼叫都需開發者自行處理錯誤（例如try/except），缺乏集中管控。不同模組錯誤處理不一致，增加開發負擔。 |
| **擴展性**   | **易於擴充**：透過新增 Agent 或 Tool 即可擴充功能，彼此介面標準化，對現有系統影響小。例如新增一個Agent就像增加一個微服務，系統具備天然彈性。 | **擴充困難**：單體架構下增加新功能往往牽一髮動全身，需要改動集中代碼。隨著功能增多，系統變得臃腫難維護，擴展成本高。             |

*（註：上表中將 MCP 模式與傳統 API 串接統稱一類，因兩者在架構上皆屬單體代理調用外部資源，雖標準化程度不同但開發者心智模型相近。）*

從上表可見，ADK/A2A 所代表的多代理架構在**系統內聚性與鬆耦合**方面更具優勢。開發者能以類似微服務的方式構建AI Agent，透過標準協定通信，使每個部分關注自身職責而不干涉他人。反之，傳統單體模式下，各功能組件緊密交織在同一流程中，靈活性與可擴展性受到限制。一旦某部分需要修改或替換，往往涉及整條流程的調整。寫到這邊，篇幅有點太長，接下來，我將從開發者**思維模型與任務劃分**角度，看這種轉變對工程師日常開發有何影響。

這篇文章引用了Simon Liu對ADK/MCP/A2A的介紹以及Koyeb對A2A和MCP協議的技術博客分析。內容可能包含誤解，但我已盡力理解並完成這篇文章。

值得注意的是，由於這些技術相對較新（全部在2024年底至2025年初之間推出），一些細節可能仍在開發中，尤其是因為A2A協議的版本僅為0.1.0，這表明它可能仍處於早期階段。隨著這些技術的成熟和更廣泛的採用，未來可能會出現更多功能和最佳實踐。